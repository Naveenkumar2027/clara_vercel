<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Session Call</title>
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://unpkg.com/framer-motion@10/dist/framer-motion.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .card {
            background: white;
            border-radius: 15px;
            padding: 25px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            margin-bottom: 20px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            margin: 5px;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-success {
            background: #48bb78;
            color: white;
        }
        .btn-danger {
            background: #f56565;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <h1>Test Session Call System</h1>
            <p>This page tests the session-based call system between client and staff.</p>
            
            <div id="testControls">
                <button class="btn btn-primary" onclick="createTestSession()">Create Test Session</button>
                <button class="btn btn-success" onclick="initiateTestCall()">Initiate Test Call</button>
                <button class="btn btn-danger" onclick="endTestCall()">End Test Call</button>
            </div>
            
            <div id="status" style="margin-top: 20px; padding: 10px; background: #f7fafc; border-radius: 8px;">
                <strong>Status:</strong> <span id="statusText">Ready</span>
            </div>
        </div>

        <div class="card">
            <h2>Session Information</h2>
            <div id="sessionInfo">
                <p>No active session</p>
            </div>
        </div>

        <div class="card">
            <h2>Call Information</h2>
            <div id="callInfo">
                <p>No active call</p>
            </div>
        </div>
    </div>

    <script type="text/babel">
        const { useState, useEffect } = React;
        const { motion } = Motion;

        let socket;
        let currentSession = null;
        let currentCall = null;

        // Minimal WebRTC state for the test client (client side only)
        let pc = null;
        let localStream = null;
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Initialize socket connection
        function initializeSocket() {
            socket = io();
            
            socket.on('connect', () => {
                updateStatus('Connected to server');
            });

            socket.on('disconnect', () => {
                updateStatus('Disconnected from server');
            });

            // Listen for session events
            socket.on('session_created', (data) => {
                console.log('Session created:', data);
                currentSession = data;
                updateSessionInfo(data);
                updateStatus('Session created successfully');
            });

            socket.on('session_call_notification', (data) => {
                console.log('Call notification received:', data);
                currentCall = data;
                updateCallInfo(data);
                updateStatus('Incoming call notification received');
            });

            socket.on('call_accepted', (data) => {
                console.log('Call accepted:', data);
                // Friendly message to the client when staff accepts
                updateStatus('âœ… Your call was accepted by staff. Connecting...');
                // If this acceptance belongs to our session, prepare PC if not ready
                if (currentCall && data.sessionId === currentCall.sessionId) {
                    ensurePeerConnection();
                }
            });

            socket.on('call_declined', (data) => {
                console.log('Call declined:', data);
                updateStatus('Call declined');
            });

            socket.on('call_ended', (data) => {
                console.log('Call ended:', data);
                currentCall = null;
                updateCallInfo(null);
                updateStatus('Call ended');
                cleanupWebRTC();
            });

            // --- WebRTC signaling for the test client ---
            socket.on('call_offer', async (data) => {
                try {
                    if (!currentCall || data.sessionId !== currentCall.sessionId) return;
                    await ensurePeerConnection();
                    await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
                    // Ensure we have local stream
                    await ensureLocalStream();
                    const answer = await pc.createAnswer();
                    await pc.setLocalDescription(answer);
                    socket.emit('call_answer', { sessionId: currentCall.sessionId, answer });
                } catch (err) {
                    console.error('Error handling offer on client:', err);
                }
            });

            socket.on('call_answer', async (data) => {
                // For completeness (not usually needed on client in this flow)
                console.log('Answer received at client (noop):', data?.sessionId);
            });

            socket.on('ice_candidate', async (data) => {
                try {
                    if (!currentCall || data.sessionId !== currentCall.sessionId) return;
                    await ensurePeerConnection();
                    if (data.candidate) {
                        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                } catch (err) {
                    console.error('Error adding ICE candidate on client:', err);
                }
            });
        }

        function updateStatus(message) {
            document.getElementById('statusText').textContent = message;
        }

        function updateSessionInfo(session) {
            const container = document.getElementById('sessionInfo');
            if (session) {
                container.innerHTML = `
                    <p><strong>Session ID:</strong> ${session.sessionId}</p>
                    <p><strong>Client ID:</strong> ${session.clientId}</p>
                    <p><strong>Staff ID:</strong> ${session.staffId}</p>
                    <p><strong>Client Name:</strong> ${session.clientName}</p>
                    <p><strong>Staff Name:</strong> ${session.staffName}</p>
                    <p><strong>Purpose:</strong> ${session.purpose}</p>
                `;
            } else {
                container.innerHTML = '<p>No active session</p>';
            }
        }

        function updateCallInfo(call) {
            const container = document.getElementById('callInfo');
            if (call) {
                container.innerHTML = `
                    <p><strong>Call Type:</strong> ${call.callType}</p>
                    <p><strong>Caller Name:</strong> ${call.callerName}</p>
                    <p><strong>Caller Role:</strong> ${call.callerRole}</p>
                    <p><strong>Session ID:</strong> ${call.sessionId}</p>
                `;
            } else {
                container.innerHTML = '<p>No active call</p>';
            }
        }

        function createTestSession() {
            const sessionData = {
                clientId: 'test-client-123',
                staffId: 'ACS', // Prof. Anitha C S
                purpose: 'Test session call'
            };

            fetch('/api/sessions/create', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(sessionData)
            })
            .then(response => response.json())
            .then(data => {
                if (data.success) {
                    // Join the session
                    socket.emit('create_session', {
                        sessionId: data.sessionId,
                        clientId: data.clientId,
                        staffId: data.staffId,
                        purpose: sessionData.purpose
                    });
                } else {
                    updateStatus('Failed to create session: ' + data.error);
                }
            })
            .catch(error => {
                console.error('Error creating session:', error);
                updateStatus('Error creating session');
            });
        }

        function initiateTestCall() {
            // Emit global call_initiated event for Call Updates container
            const sessionId = 'test-session-' + Date.now();
            socket.emit('call_initiated', {
                staffId: 'ACS', // Prof. Anitha C S
                clientName: 'Test Client',
                callType: 'video',
                sessionId: sessionId,
                clientId: 'test-client-123',
                callerId: 'test-caller',
                callerName: 'Test Client',
                callerRole: 'user'
            });

            updateStatus('Call initiated for Prof. Anitha C S - Session: ' + sessionId);
            // Track current call locally for scoping
            currentCall = { sessionId, callType: 'video', callerName: 'Test Client', callerRole: 'user' };
            updateCallInfo(currentCall);
            // Prepare local media early so we can answer quickly
            ensureLocalStream();
        }

        function endTestCall() {
            if (!currentCall) {
                updateStatus('No active call to end.');
                return;
            }

            socket.emit('session_call_ended', {
                sessionId: currentCall.sessionId
            });

            updateStatus('Call ended');
            cleanupWebRTC();
        }

        // --- Helpers: WebRTC for client ---
        async function ensurePeerConnection() {
            if (pc) return pc;
            pc = new RTCPeerConnection(rtcConfig);
            pc.onicecandidate = (e) => {
                if (e.candidate && currentCall) {
                    socket.emit('ice_candidate', { sessionId: currentCall.sessionId, candidate: e.candidate });
                }
            };
            pc.onconnectionstatechange = () => {
                console.log('Client PC state:', pc.connectionState);
            };
            // We don't render remote video here (staff sees client only per requirement)
            return pc;
        }

        async function ensureLocalStream() {
            if (localStream) return localStream;
            localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
            await ensurePeerConnection();
            localStream.getTracks().forEach(t => pc.addTrack(t, localStream));
            return localStream;
        }

        function cleanupWebRTC() {
            try {
                if (localStream) {
                    localStream.getTracks().forEach(t => t.stop());
                    localStream = null;
                }
                if (pc) {
                    pc.close();
                    pc = null;
                }
            } catch (e) {
                console.warn('Cleanup error:', e);
            }
        }

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', function() {
            initializeSocket();
        });
    </script>
</body>
</html>
